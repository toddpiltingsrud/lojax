Better error handling. Currently if a request fails, afterRequest doesn't fire, leaving everybody hanging.

Try blanket.js to make test writing quicker.

Figure out how to hook into client-side validation. Can we copy validation attributes when we create dynamic forms?
"To parse new HTML, you can call the jQuery.validator.unobtrusive.parse() method, passing it a selector for the HTML that you would like to be parsed. 
You can also call the jQuery.validator.unobtrusive.parseElement() function to parse a single HTML element." 
http://bradwilson.typepad.com/blog/2010/10/mvc3-unobtrusive-validation.html

Add support for files.

Use an object proxy to provide two-way binding for data models.

Support callback parameters for JSONP.

For caching, set a default expiration. Add the ability to expire a cached item after it's requested the first time.

Use data-model to reuse chunks of HTML. Store a chunk of HTML using it's url as the key. Then just swap out its data-model.
How can we use familiar patterns to do this? We could load a resource and specify that we want it cached.
Then use the same click handling logic to load that resource with a data model.
But the data-model needs its own URL. We're looking at specifying 2 url's: one for the template, the other for the data model.
Further, we might want to be able to specify that the template should be pre-loaded. 
Perhaps we should build a couple working examples using the code we have, then tease out a pattern.

Turn modal creation into a service that controls the lifetime of modals. 
It needs to be able to import modals and keep their content around if necessary.

Allow the attribute prefix (jx) to be changed.

So the modal could be opened multiple times, and optionally downloaded from the server every time.

Consider replacing jquery's event triggering mechanism with my own. Need custom events that bubble. 
Currently, all events must be triggered and handled on window.document. This doesn't follow the event pattern.

Create a nuget package.

Supported scenarios/patterns:

- Clicking an element executes a request with optional form or model.
- Specify data-trigger = change to handle the change event on an element containing inputs and execute a request with optional form or model
- An element with data-method and data-trigger containg 'enter' executes a request with optional form or model when enter key is pressed.
- Clicking a submit button inside a form with a data-method attribute executes a request with the form.
- Clicking a submit button inside an element with a data-model attribute executes a request with the model.
- Add an empty data-model attribute to any parent element to create a JSON model from the child inputs.
- A non-empty data-model attribute on a parent element will set the values of the child inputs to the model by matching model properties to input names.
- Change the url's hash to trigger an ajax-get request. Simple way to get cross-browser navigation history for ajax requests.
- If input elements are inside an element with a data-model attribute, the change event writes the changes to the data model.
- Add a data-src attribute to a div to load content into the div asynchronously. This uses the same logic as data-jaxpanels, so you can use transitions, model binding, other data-src divs, etc.
- Use lojax.in(callback) inside a jx-panel, modal, or div[data-src] to execute a function with context ('this' keyword) set to the containing element.
  This works only if the script is inside the element you want as the context.
  The callback is invoked after model binding, but before loadDataSrcDivs. Callbacks are invoked only once.
- Post a JSON model without ajax. This works by converting the model into a form and submitting it.

AJAX responses:

- Parse response into a collection of nodes.
- If there are no nodes, return.
- Trigger the beforeInject event with the node list as an argument.
- Check the request for a target. If found, inject all the nodes into the target.
- Iterate through the nodes.
- If there is not currently a modal being displayed and the node is a modal, instantiate a modal and show it. Continue.
- If there is not currently a modal being displayed and the node contains a modal, instantiate a modal and show it.
- If the node is a jx-panel, inject it.
- If the node contains data-jaxpanels, inject them.
- Once we're done iterating through the nodes, check for any loose script and style nodes. Inject them into a hidden div at the bottom of the page.

Modal Creation

- Supports bootstrap and kendo
- Modal content is appended to document body and a modal is instantiated and shown.
- Optional: Call lojax.closeModal() to close the modal.
- Handle the modal's hidden/close event and null out the modal instance and remove the element from the DOM.

Tips: 
- Use a layout to create modals on the server.
- Use cache="prefetch" for modals to retrieve them before they are requested. Then bind them to a model.
- Use a publish/subscribe pattern instead of a callback URL query parameter to receive JSONP responses.
  Use an attenuated version of the URL as the event name (app/controller/action).
  This is also useful for letting the client know when something important has happened on the server (e.g. app/customer/update).
  Different parts of the app can react to actions on the server without having actually initiated them.
  This creates a cleaner separation of concerns in your client-side code. 
  For example, you could use a modal to update a resource without forcing the modal to update other parts of the UI.